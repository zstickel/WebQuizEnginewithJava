<h2>Class Loader</h2>
<div class="step-text">
<p><br/></p>
<p>A typical enterprise Java application may comprise thousands of source and dependency classes. To handle all of them in a proper way JVM introduces a special mechanism called <strong><a class="theory-lookup not-relevant" href="/learn/step/12593" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a class loader is an abstract class responsible for loading classes into the Java Virtual Machine (JVM). | There are three standard implementations: the bootstrap class loader, the extension class loader, and the application class loader. The bootstrap class loader loads core classes, followed by the extension class loader, which loads classes from the JDK extension directory. Finally, the application class loader loads classes from the application's classpath. Classes are loaded on-demand during interpretation, starting with a class containing the method. Custom class loaders can override the default loading behavior, allowing for flexibility in resolving classes.">class loader</a></strong>. It is a part of <strong>JRE</strong> responsible for dynamic loading classes into memory. Understanding class loading allows to control this process and helps to avoid some types of exceptions.</p>
<p>First of all, let's recall that java code goes through 2 stages: a compilation from <a class="theory-lookup not-relevant" href="/learn/step/12593" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a source code is the human-readable text version of a program written in the Java programming language. | It is typically stored in a file with a .java extension and can be edited using a text editor or an Integrated Development Environment (IDE). The source code is compiled by the Java compiler into bytecode, which is a low-level, platform-independent representation of the program. This bytecode can then be executed by the Java Virtual Machine (JVM) on any platform that has a JVM installed. The source code can also be decompiled back into readable Java code using a decompiler.">source code</a> to byte code (<code class="language-java">.java</code> -&gt; <code class="language-java">.class</code>) and a byte code interpretation. The task of a class loader is finding the needed class through <code class="language-java">.class</code> files from a disc and loading a representing object into the RAM. However, classes are not loaded in bulk mode on the application startup. A class loader loads them on-demand during an interpretation starting with a class containing the <code class="language-java">main</code> method. The on-demand approach means that the class will be loaded on its first invocation. It can be a constructor call, e.g. new <code class="language-java">MyObject()</code> or a static reference to a class, e.g. <code class="language-java">System.out</code></p>
<h5 id="internals">Internals</h5>
<p>A <strong>class loader</strong> concept is represented by <code class="language-java">java.lang.ClassLoader</code> <a class="theory-lookup not-relevant" href="/learn/step/12593" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an abstract class is a class declared with the keyword abstract that represents an abstract concept and is used as a base class for subclasses. | It can have fields, constructors, and abstract methods, which are declared by adding the keyword abstract and have a declaration (modifier, a return type, and a signature) but don't have an implementation. Each concrete (non-abstract) subclass must implement these abstract methods. An abstract class cannot be instantiated, and its abstract method's implementation is provided by concrete subclasses.">abstract class</a>. There are 3 standard <code class="language-java">ClassLoader</code> implementations:</p>
<ul><li><p><strong>Bootstrap</strong> loads JDK internal classes e.g. <code class="language-java">java.util</code> package.</p></li><li><p><strong>Extension/Platform</strong> loads classes from JDK extensions.</p></li><li><p><strong>Application/System</strong> loads classes from application <strong>classpath.</strong></p></li></ul>
<p>One may ask what comes first if classes are loaded by a class loader and the <code class="language-java">ClassLoader</code> itself is a class. To answer the question let's consider a sequence of these <code class="language-java">ClassLoaders</code> invocations. First, JRE creates the <strong>Bootstrap</strong> <code class="language-java">ClassLoader</code> which loads core classes. Then, <strong>Extension</strong> <code class="language-java">ClassLoader</code> is created with <strong>Bootstrap</strong> as a parent. It loads classes for extensions if such exist. Finally, the <strong>Application </strong><code class="language-java">ClassLoader</code> is created with <strong>Extension</strong> as a parent. It is responsible for loading application classes from a classpath. Each class loaded in memory is identified by a fully-qualified class name and <code class="language-java">ClassLoader</code> that loaded this class. Moreover, <code class="language-java">Class</code> has a method <code class="language-java">getClassLoader</code> that returns the class loader which loads the given class.</p>
<p>Take a look at the example:</p>
<pre><code class="language-java">import java.sql.SQLData;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ClassLoader listClassLoader = ArrayList.class.getClassLoader();
        ClassLoader sqlClassLoader = SQLData.class.getClassLoader();
        ClassLoader mainClassLoader = Main.class.getClassLoader();

        System.out.println(listClassLoader); // null
        System.out.println(sqlClassLoader.getName()); // platform
        System.out.println(mainClassLoader.getName()); // app
    }
}
</code></pre>
<h5 id="delegation-model">Delegation model</h5>
<p>When the class loader receives a request for loading a class, it follows certain steps in order to resolve the class. Default behavior defined by JVM specification:</p>
<ol><li><p>Check if the class has already been loaded</p></li><li><p>If not, delegate the request to a parent</p></li><li><p>If the parent class returns nothing, it attempts to find the class in its own classpath</p></li></ol>
<p style="text-align: center;"><picture><img alt="request to load class" height="972" src="https://ucarecdn.com/1f09636f-b38b-4a85-ae4c-c96a4cf695b5/" width="1474"/></picture></p>
<p>Default logic can be overridden in custom class loaders. So web container class loaders will look for classes in the local <strong>classpath</strong> and only in case the class is not found will delegate resolving to a parent.</p>
<h5 id="example">Example</h5>
<p>Let's consider an application that consists of 2 classes. Although it does nothing, it is a good example of a class loader explanation.</p>
<pre><code class="language-java">public class A {
    public static void main(String[] args) {
        B b = new B();
    }
}</code></pre>
<pre><code class="language-java">public class B {
}</code></pre>
<p>Launch the program by command:</p>
<pre><code class="language-bash">java A</code></pre>
<p>Let's go through key points of class loading during code execution:</p>
<ol><li><p>Bootstrap <code class="language-java">ClassLoader</code> is invoked by JRE on the start <code class="language-java">java</code> process. It loads <code class="language-java">java</code> internal packages.</p></li><li><p>Extension <code class="language-java">ClassLoader</code> is invoked but loads nothing.</p></li><li><p>Application <code class="language-java">ClassLoader</code> is invoked and loads class <code class="language-java">A</code>.</p></li><li><p>When the constructor of class <code class="language-java">B</code> is invoked <code class="language-java">ClassLoader</code> of class <code class="language-java">A</code> (Application <code class="language-java">ClassLoader</code>) is invoked to load class <code class="language-java">B</code> and delegates loading to Extension <code class="language-java">ClassLoader</code>.</p></li><li><p>Extension <code class="language-java">ClassLoader</code> is invoked and delegates loading to Bootstrap <code class="language-java">ClassLoader</code>.</p></li><li><p>Bootstrap <code class="language-java">ClassLoader</code> is invoked and tries to resolve the class, but finds nothing and returns control to Extension <code class="language-java">ClassLoader</code>.</p></li><li><p>Extension <code class="language-java">ClassLoader</code> finds nothing as well and returns control to Application <code class="language-java">ClassLoader</code>.</p></li><li><p>Application <code class="language-java">ClassLoader</code> resolves the class and loads it into memory.</p></li></ol>
<h5 id="when-something-goes-wrong">When something goes wrong</h5>
<p>Let's have a quick glance at problems related to class loaders. The common root cause comes because runtime dependencies may differ from compile-time ones. For instance, a project may be <a class="theory-lookup not-relevant" href="/learn/step/12593" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a compile is the process of translating source code into bytecode that can be executed by the Java Virtual Machine (JVM). | During compilation, the Java compiler checks the code for errors, such as typos, incorrect method invocations, and mismatched variable declarations. If any errors are found, the code will not compile and an error message will be generated. To avoid compile-time errors, programmers can use tools like Integrated Development Environments (IDEs) with static code analyzers, which can identify and highlight potential errors before the code is compiled.">compiled</a> successfully, but some classes were not added to the classpath. In that case, a class loader cannot find a class. That leads to <code class="language-java">ClassNotFoundException</code> or <code class="language-java">NoClassDefFoundError</code>. Another kind of exception happens because a project was compiled with one version of a class, but the classpath includes a different one. In that case <code class="language-java">NoSuchMethodError</code> or <code class="language-java">NoSuchFieldError</code> are thrown.</p>
<h5 id="conclusion">Conclusion</h5>
<p>A class loader is a part of JRE that loads byte code classes from a <a class="theory-lookup not-relevant" href="/learn/step/12593" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a file system is a way to organize and store data in files, which are stored on a disk or another device. | These files can be organized into directories, which act as folders for other files and directories. In Java, you can use the `File` class in the `java.io` package to work with file systems. This class allows you to create, delete, and rename files and directories, as well as traverse the file hierarchy. A file is represented as an abstract path, which may not even exist. When you create an instance of the `File` class, you can specify the abstract path to the file or directory.">file system</a> into RAM. It is a dynamic on-demand concept. There are 3 standard class loaders: bootstrap, platform, and system. A class loading process is performed according to a <a class="theory-lookup not-relevant" href="/learn/step/12593" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a delegation model refers to the default behavior defined by the JVM specification for class loading. | When the JVM encounters a request to load a class, it first checks if the class has already been loaded. If not, it delegates the request to a parent class loader. If the parent class loader returns nothing, it then attempts to find the class in its own classpath. This default logic can be overridden in custom class loaders. For example, in a web container, the class loader will first look for the class in the local classpath and only if the class is not found will it delegate resolving to a parent.">delegation model</a>. Although dealing with classloading is not a daily job for most programmers, understanding the concept helps to investigate some types of exceptions. It is highly required for building complex systems like web frameworks as well.</p>
</div>
